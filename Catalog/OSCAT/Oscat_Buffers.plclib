<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcLibrary schemaVersion="2.9">
	<lib version="1.0.1" name="Oscat - Buffers" fullXml="true">
		<descr>Buffer Management. Author URL: http://oscat.de</descr>
		<libWorkspace>
			<folder name="Oscat - Buffers" excludeFromBuild="false" excludeFromBuildIfNotDef="">
				<Pou name="_BUFFER_CLEAR"/>
				<Pou name="_BUFFER_INIT"/>
				<Pou name="_BUFFER_INSERT"/>
				<Pou name="_BUFFER_UPPERCASE"/>
				<Pou name="_STRING_TO_BUFFER"/>
				<Pou name="BUFFER_SEARCH"/>
				<Pou name="BUFFER_COMP"/>
			</folder>
		</libWorkspace>
		<globalVars/>
		<retainVars/>
		<constantVars/>
		<functions>
			<function name="_BUFFER_CLEAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="PT" type="@BYTE"/>
						<var name="SIZE" type="UINT"/>
					</inputVars>
					<localVars>
						<var name="ptw" type="@DWORD"/>
						<var name="temp" type="DWORD"/>
						<var name="end" type="DWORD"/>
						<var name="end32" type="DWORD"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.2	31. oct. 2008
programmer 	hugo
tested by	oscat

this function will initialize a given array of byte with 0.
the function needs to be called:	_buffer_clear(adr(array),sizeof(array));
this function will manipulate a given array.
the function manipulates the original array, it rerturnes true when finished.
because this function works with pointers its very time efficient and it needs no extra memory.

*)

(* this routine uses 32 bit access to gain speed *)
(* first access bytes till pointer is aligned for 32 bit access *)
temp := pt;
end := temp + TO_DWORD(size);
end32 := end - 3;
WHILE (pt < end) AND ((temp AND 16#00000003) > 0) DO
	@pt := 0;
	pt := pt + 1;
	temp := temp + 1;
END_WHILE;
(* pointer is aligned, now copy 32 bits at a time *)
ptw := pt;
WHILE ptw < end32 DO (* *)
	@ptw := 0;
	ptw := ptw + 4;
END_WHILE;
(* copy the remaining bytes in byte mode *)
pt := ptw;
WHILE pt < end DO
	@pt := 0;
	pt := pt + 1;
END_WHILE;

_BUFFER_CLEAR := TRUE;

(* revision History
hm 	5. mar. 2008	rev 1.0
	original version

hm	16. mar. 2008	rev 1.1
	added type conversion to avoid warnings under codesys 30
	chaged type of input size to uint
	deleted unused variable i

hm	31. oct. 2008	rev 1.2
	corrected an error while routine would write outside of arrays

*)
]]>
				</sourceCode>
			</function>
			<function name="_BUFFER_INIT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="PT" type="@BYTE"/>
						<var name="SIZE" type="UINT"/>
						<var name="INIT" type="BYTE"/>
					</inputVars>
					<localVars>
						<var name="ptw" type="@DWORD"/>
						<var name="temp" type="DWORD"/>
						<var name="end" type="DWORD"/>
						<var name="end32" type="DWORD"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.2	31. oct. 2008
programmer 	hugo
tested by	oscat

this function will initialize a given array of byte with init.
the function needs to be called:	_buffer_init(adr(array),sizeof(array),init);
this function will manipulate a given array.
the function manipulates the original array, it rerturnes true when finished.
because this function works with pointers its very time efficient and it needs no extra memory.

*)

(* this routine uses 32 bit access to gain speed *)
(* first access bytes till pointer is aligned for 32 bit access *)
temp := pt;
end := temp + TO_DWORD(size);
end32 := end - 3;
WHILE (pt < end) AND ((temp AND 16#00000003) > 0) DO
	@pt := init;
	pt := pt + 1;
	temp := temp + 1;
END_WHILE;
(* pointer is aligned, now copy 32 bits at a time *)
ptw := pt;
temp := SHL(TO_DWORD(init),24) OR SHL(TO_DWORD(init),16) OR SHL(TO_DWORD(init),8) OR TO_DWORD(init);
WHILE ptw < end32 DO
	@ptw := temp;
	ptw := ptw + 4;
END_WHILE;
(* copy the remaining bytes in byte mode *)
pt := ptw;
WHILE pt < end DO
	@pt := init;
	pt := pt + 1;
END_WHILE;

_BUFFER_INIT := TRUE;

(* revision History
hm 	5. mar. 2008	rev 1.0
	original version

hm	16. mar. 2008	rev 1.1
	added type conversion to avoid warnings under codesys 3.0
	chaged type of input size to uint.

hm	31. oct. 2008	rev 1.2
	corrected an error while routine would write outside of arrays

*)
]]>
				</sourceCode>
			</function>
			<function name="_BUFFER_INSERT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	STR : STRING[STRING_LENGTH];
	POS : INT;
	PT : @BYTE;
	SIZE : UINT;
END_VAR
VAR
	end : INT;
	lx: INT;
	i: INT;
END_VAR


(*
version 1.5	2. jan. 2012
programmer 	hugo
tested by	oscat

this function will insert a string at a given position in a buffer.
the function needs to be called:	_buffer_init(adr(array),sizeof(array),init);
this function will manipulate a given array.
the function manipulates the original array, it returnes the next position after the input string when finished.
because this function works with pointers its very time efficient and it needs no extra memory.

*)

lx := LEN(str);
end := pos + lx;
(* first move the upper part of the buffer to make space for the string *)
FOR i := TO_INT(size) - 1 TO end BY -1 DO
	@pt[i] := @pt[i-lx];
END_FOR;
(* copy the string *)
_BUFFER_INSERT := _STRING_TO_BUFFER(str, pos, PT, size);


(* revision History
hm 	9. mar. 2008	rev 1.0
	original version

hm	16. mar. 2008	rev 1.1
	changed type of input size to uint

hm	13. may. 2008	rev 1.2
	changed type of pointer to array[1..32767]
	changed size of string to STRING_LENGTH

hm	23. mar. 2009	rev 1.3
	avoid writing to input pos

hm	12. nov. 2009	rev 1.4
	code optimized

hm 2. jan 2012	rev 1.5
	function now returns the next position after the input string

*)
]]>
				</sourceCode>
			</function>
			<function name="_BUFFER_UPPERCASE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="PT" type="@BYTE"/>
						<var name="SIZE" type="INT"/>
					</inputVars>
					<localVars>
						<var name="pos" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	20. jan. 2011
programmer 	hugo
tested by	oscat

this function will convert an array of byte into uppercase
the function needs to be called:	_buffer_clear(adr(array),sizeof(array));
this function will manipulate a given array.
the function manipulates the original array, it rerturnes true when finished.
because this function works with pointers its very time efficient and it needs no extra memory.

*)

pos := 0;
WHILE pos < size DO
	@PT[pos] := TO_UPPER(@pt[pos]);
	pos := pos + 1;
END_WHILE;

_BUFFER_UPPERCASE := TRUE;

(* revision History
hm 	20. jan. 2011	rev 1.0
	original version

*)
]]>
				</sourceCode>
			</function>
			<function name="_STRING_TO_BUFFER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	STR : STRING[STRING_LENGTH];
	POS : INT;
	PT : @BYTE;
	SIZE : UINT;
END_VAR
VAR
	ps : @BYTE;
	i: INT;
	end: INT;
END_VAR


(*
version 1.4	2. jan. 2012
programmer 	hugo
tested by		oscat

this function will copy a string into an array of byte starting at position pos.
the function needs to be called:	_String_To_buffer(str, pos, adr(array),sizeof(array));
this function will manipulate the array directly in memory and returns the position after the input string when finished.
because this function works with pointers its very time efficient and it needs no extra memory.

*)

ps := ADR(str);
end := MIN(pos + LEN(str), TO_INT(size));
IF end > 0 THEN end := end -1; END_IF;
FOR i := pos TO end DO
	@pt[i] := @ps;
	ps := ps + 1;
END_FOR;

_STRING_TO_BUFFER := i;

(* revision History

hm 	5. mar. 2008	rev 1.0
	original version

hm	16. mar. 2008	rev 1.1
	changed type of input size to uint

hm	13. may. 2008	rev 1.2
	changed type of pointer to array[1..32767]
	changed size of string to STRING_LENGTH

hm	12. nov. 2009	rev 1.3
	limit end to size - 1

hm	2. jan 2012	rev 1.4
	return the position after the input string when finished
*)
]]>
				</sourceCode>
			</function>
			<function name="BUFFER_SEARCH" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="PT" type="@BYTE"/>
						<var name="SIZE" type="INT"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	PT : @BYTE;
	SIZE : INT;
	STR : STRING[STRING_LENGTH];
	POS : INT;
	IGN : BOOL;
END_VAR
VAR
	ps : @BYTE;
	chx : BYTE;
	i: INT;
	end: INT;
	k: INT;
	lx: INT;
END_VAR


(*
version 1.4	25. jan 2011
programmer 	hugo
tested by	oscat

this function will search for a string STR in an array of byte starting at position pos.
the function needs to be called: buffer_search(adr(array),sizeof(array), STR, POS, IGN);
because this function works with pointers its very time efficient and it needs no extra memory.
The function returns the position of the first character of the string in the array if found.
a -1 is returned if the string is not found in the array.
when IGN = TRUE, STR must be in capital letters and the search is case insensitv.

*)

ps := ADR(STR);
lx := LEN(STR);
end := MIN(SIZE - lx, SIZE - 1);
lx := lx - 1;
FOR i := pos TO end DO
	FOR k := 0 TO lx DO
		IF IGN THEN chx := TO_UPPER(@pt[i+k]); ELSE chx := @pt[i+k]; END_IF;
		IF @ps[k] <> chx THEN EXIT; END_IF;
	END_FOR;
	IF k > lx THEN
		BUFFER_SEARCH := i;
		RETURN;
	END_IF;
END_FOR;
BUFFER_SEARCH := -1;


(* revision History

hm 5. mar. 2008	rev 1.0
	original version

hm	16. mar. 2008	rev 1.1
	chaged type of input size to uint

hm	13. may. 2008	rev 1.2
	changed type of pointer to array[1..32767]
	changed size of string to STRING_LENGTH

hm	12. nov. 2009	rev 1.3
	limit end to array size

hm	25. jan. 2011	rev 1.4
	ign = True will now ignore case
	return -1 if nothing found
*)
]]>
				</sourceCode>
			</function>
			<function name="BUFFER_COMP" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="PT1" type="@BYTE"/>
						<var name="SIZE1" type="INT"/>
						<var name="PT2" type="@BYTE"/>
						<var name="SIZE2" type="INT"/>
						<var name="START" type="INT"/>
					</inputVars>
					<localVars>
						<var name="i" type="INT"/>
						<var name="j" type="INT"/>
						<var name="end" type="INT"/>
						<var name="firstbyte" type="BYTE"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	12. nov. 2009
programmer 	hugo
tested by	oscat


 
*)

(* search for first character match *)
IF size2 <= size1 THEN
	end := size1 - size2;
	firstbyte := @PT2[0];
	FOR i := START TO end DO
		IF @PT1[i] = firstbyte THEN
			(* first character matches, now compare rest of array *)
			j := 1;
			WHILE j < size2 DO
				IF @pt2[j] <> @pt1[j+i] THEN EXIT; END_IF;
				j := j + 1;
			END_WHILE;
			(* when J > size2 a match was found return the position i in buffer1 *)
			IF j = size2 THEN
				BUFFER_COMP := i;
				RETURN;
			END_IF;
		END_IF;
	END_FOR;
END_IF;
BUFFER_COMP := -1;


(*
hm 14. nov. 2008	rev 1.0
	original version

hm	12. nov. 2009	rev 1.1
	performance increase

*)
]]>
				</sourceCode>
			</function>
		</functions>
		<functionBlocks/>
		<programs/>
		<macros/>
		<structs/>
		<typedefs/>
		<enums/>
		<subranges/>
		<interfaces/>
	</lib>
</plcLibrary>
