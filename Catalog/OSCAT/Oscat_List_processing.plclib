<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcLibrary schemaVersion="2.9">
	<lib version="1.0.1" name="Oscat - List processing" fullXml="true">
		<descr>Author URL: http://oscat.de</descr>
		<libWorkspace>
			<folder name="Oscat - List processing" excludeFromBuild="false" excludeFromBuildIfNotDef="">
				<Pou name="LIST_NEXT"/>
				<Pou name="LIST_INSERT"/>
				<Pou name="LIST_ADD"/>
				<Pou name="LIST_CLEAN"/>
				<Pou name="LIST_LEN"/>
			</folder>
		</libWorkspace>
		<globalVars/>
		<retainVars/>
		<constantVars/>
		<functions>
			<function name="LIST_INSERT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="SEP" type="BYTE"/>
						<var name="POS" type="INT"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	SEP : BYTE;
	POS : INT;
	INS : STRING[LIST_LENGTH];
END_VAR
VAR
	LIST : STRING[LIST_LENGTH];
END_VAR
VAR
	pt : @BYTE;
	read : INT ;
	cnt : INT ;
	sx : STRING[1];
END_VAR


(*
version 2.0	21. mar. 2011
programmer 	hugo
tested by		oscat

LIST_INSERT setzt ein element an der stelle pos in eine liste ein.
die liste liegt als string von elementen vor die mit den zeichen SEP am anfang markiert sind.

*)

(* load pointers *)
pt := ADR(LIST);

IF LEN(ins) + 1 + LEN(LIST) > LIST_LENGTH THEN
	LIST_INSERT := FALSE;
ELSE
	LIST_INSERT := TRUE;
	(* search for position *)
	WHILE read < LIST_LENGTH DO
		IF cnt >= POS THEN
			sx := CHR_TO_STRING(SEP);
			INS := CONCAT(sx, INS);
			LIST := INSERT(LIST, INS, read - 1);
			LIST_INSERT := TRUE;
			RETURN;
		END_IF;
		IF @pt[read]  = 0 THEN				(* list is too short add empty element *)
			@pt[read] := SEP;
			@pt[read + 1] := 0;
		END_IF;
		read := read + 1;
		IF @pt[read] = SEP OR @pt[read] = 0 THEN cnt := cnt + 1; END_IF;
	END_WHILE;
END_IF;



(* revision histroy
hm	28. jun. 2008	rev 1.0
	original release

hm	17. dec. 2008	rev 1.1
	changes name of function chr to chr_to_string

hm	19. jan. 2011	rev 1.2
	changed string(255) to string(LIST_LENGTH)

hm	21. mar. 2011	rev 2.0
	all list elements start with SEP
	
*)	

]]>
				</sourceCode>
			</function>
			<function name="LIST_ADD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="SEP" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	SEP : BYTE;
	INS : STRING[LIST_LENGTH];
END_VAR
VAR
	LIST : STRING[LIST_LENGTH];
END_VAR
VAR
	sx : STRING[1];
END_VAR


(*
version 2.0		21. mar. 2011
programmer 	hugo
tested by		kurt

LIST_ADD hÃ¤ngt ein weiteres element ans ende einer liste.
die liste liegt als string von elementen vor die mit den zeichen SEP am anfang makiert sind.

*)

sx := CHR_TO_STRING(SEP);			(* convert separation character to string *)
INS := CONCAT(sx, INS);					(* start element with separation character *)

IF LEN(LIST) + LEN(INS) > LIST_LENGTH THEN
	LIST_ADD := FALSE;					(* return false if element does not fit *)
ELSE
	LIST := CONCAT(LIST, INS);
	LIST_ADD := TRUE;
END_IF;


(* revision histroy

hm	21. mar. 2011	rev 2.0
	original release
*)	

]]>
				</sourceCode>
			</function>
			<function name="LIST_CLEAN" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="SEP" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR
	LIST : STRING[LIST_LENGTH];
END_VAR
VAR
	pt : @BYTE;
	read : INT ;
	write : INT ;
	last: BYTE;
	c: BYTE;
END_VAR


(*
version 2.0	21. mar. 2011
programmer 	hugo
tested by		oscat

LIST_CLEAN bereinigt eine liste von leeren Elementen.
die liste liegt als string von elementen vor die mit den zeichen SEP am anfang markiert sind.

*)

pt := ADR(LIST);

FOR read := 1 TO LIST_LENGTH DO
	c := @pt[read];								(* read character from list *)
	IF c = 0 THEN EXIT;						(* exit the loop if character definbes end of string *)
	ELSIF c <> SEP OR sep <> last THEN	(* copy element from read to write position unless a double sep character is present *)
		@pt[write] := c;
		write := write + 1;
	END_IF;
	last := c;									(* remember last character *)
END_FOR;

IF last = SEP THEN write := write - 1; END_IF;		(* if last character is sep then delete empty element at end *)
IF write <= STRING_LENGTH THEN @pt[write] := 0;	 END_IF;		(* terminate string with 0 *)

LIST_CLEAN := TRUE;						(* retrun TRUE *)


(* revision histroy
hm	28. jun. 2008	rev 1.0
	original release

hm	19. jan. 2011	rev 1.1
	changed string(255) to string(LIST_LENGTH)

hm	21. mar. 2011	rev 2.0
	all elements start with SEP

*)	

]]>
				</sourceCode>
			</function>
			<function name="LIST_LEN" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="SEP" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR
	LIST : STRING[LIST_LENGTH];
END_VAR
VAR
	pt : @BYTE;
	pos: INT ;
	c: BYTE;
END_VAR


(*
version 2.0	21. mar. 2011
programmer 	hugo
tested by		oscat

LIST_LEN liefert die anzahl der elemente einer liste.
die liste liegt als string von elementen vor die mit den zeichen SEP am anfang markiert sind.

*)

pt := ADR(LIST);
LIST_LEN := 0;
REPEAT
	c := @pt[pos];
	IF c = SEP THEN LIST_LEN := LIST_LEN + 1; END_IF;
	pos := pos + 1;
UNTIL
	c = 0 OR pos > LIST_LENGTH
END_REPEAT;



(* revision histroy
hm	25. jun. 2008	rev 1.0
	original release

hm	16. oct. 2008	rev 1.1
	fixed a problem where list_len would only work up to LIST_LENGTH

hm	19. jan. 2001	rev 1.2
	changed string(255) to string(LIST_LENGTH)

hm	21. mar. 2011	rev 2.0
	all list elements start with SEP

*)	

]]>
				</sourceCode>
			</function>
		</functions>
		<functionBlocks>
			<functionBlock name="LIST_NEXT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<vars>
					<inputVars>
						<var name="SEP" type="BYTE"/>
						<var name="RST" type="BOOL"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<interfaces/>
				<methods/>
				<sourceCode type="ST">
					<![CDATA[
VAR_IN_OUT
	LIST : STRING[LIST_LENGTH];
END_VAR
VAR_OUTPUT
	LEL : STRING[LIST_LENGTH];
	NUL : BOOL;
END_VAR
VAR
	pos : INT := 1;
	pt : @BYTE;
	po : @BYTE;
	c: BYTE;
	write: INT;
END_VAR


(*
version 2.0	21. mar. 2011
programmer 	hugo
tested by		oscat

LIST_NEXT retrieves the next element of a list, starting from element 1 after reset or first init.
when the end of the lisat is reached a '' empty string is returned and NUL is set to true.
die liste liegt als string von elementen vor die mit den zeichen SEP am anfang markiert sind.

*)

pt := ADR(LIST);
po := ADR(LEL);

IF rst THEN
	pos := 1;
END_IF;

IF @pt[pos] = 0 OR pos = LIST_LENGTH THEN
	LEL := '';
	NUL := TRUE;
ELSE
	NUL := FALSE;
	write := 1;
	FOR pos := pos + 1 TO LIST_LENGTH DO
		c := @pt[pos];
		IF c = 0 OR c = SEP THEN
			@po[write] := 0;
			RETURN;
		ELSE
			@po[write] := @pt[pos];
			write := write + 1;
		END_IF;
	END_FOR;
END_IF;




(* revision histroy
hm	25. jun. 2008	rev 1.0
	original release

hm	19. jan. 2011	rev 1.1
	changed string(255) to string(LIST_LENGTH)	

hm	21. mar. 2011	rev 2.0
	all elements start with SEP

*)	

]]>
				</sourceCode>
			</functionBlock>
		</functionBlocks>
		<programs/>
		<macros/>
		<structs/>
		<typedefs/>
		<enums/>
		<subranges/>
		<interfaces/>
	</lib>
</plcLibrary>
