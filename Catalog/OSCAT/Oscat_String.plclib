<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<plcLibrary schemaVersion="2.9">
	<lib version="1.0.1" name="Oscat - String" fullXml="true">
		<descr>Author URL: http://oscat.de</descr>
		<libWorkspace>
			<folder name="Oscat - String" excludeFromBuild="false" excludeFromBuildIfNotDef="">
				<Pou name="BIN_TO_BYTE"/>
				<Pou name="BIN_TO_DWORD"/>
				<Pou name="CHARCODE"/>
				<Pou name="FINDB_NONUM"/>
				<Pou name="FIND_NONUM"/>
				<Pou name="FIND_NUM"/>
				<Pou name="FINDB_NUM"/>
				<Pou name="FINDB"/>
				<Pou name="FIND_CHAR"/>
				<Pou name="FIND_CTRL"/>
				<Pou name="CODE"/>
				<Pou name="COUNT_CHAR"/>
				<Pou name="DEC_TO_BYTE"/>
				<Pou name="DEC_TO_DWORD"/>
				<Pou name="DEC_TO_INT"/>
				<Pou name="DT_TO_STRF"/>
				<Pou name="DWORD_OF_WORD"/>
				<Pou name="DWORD_OF_BYTE"/>
				<Pou name="FSTRING_TO_WEEK"/>
				<Pou name="FSTRING_TO_MONTH"/>
				<Pou name="FSTRING_TO_WEEKDAY"/>
				<Pou name="FSTRING_TO_DWORD"/>
				<Pou name="FSTRING_TO_DT"/>
				<Pou name="FSTRING_TO_BYTE"/>
				<Pou name="IS_CTRL"/>
				<Pou name="ISC_NUM"/>
				<Pou name="IS_CC"/>
				<Pou name="ISC_CTRL"/>
				<Pou name="ISC_UPPER"/>
				<Pou name="IS_UPPER"/>
				<Pou name="IS_ALPHA"/>
				<Pou name="ISC_LOWER"/>
				<Pou name="ISC_ALPHA"/>
				<Pou name="IS_NUM"/>
				<Pou name="MESSAGE_4R"/>
				<Pou name="IS_NCC"/>
				<Pou name="IS_LOWER"/>
				<Pou name="IS_HEX"/>
				<Pou name="ISC_HEX"/>
				<Pou name="IS_ALNUM"/>
				<Pou name="MESSAGE_8"/>
				<Pou name="FINDP"/>
				<Pou name="FLOAT_TO_REAL"/>
				<Pou name="HEX_TO_BYTE"/>
				<Pou name="HEX_TO_DWORD"/>
				<Pou name="OCT_TO_DWORD"/>
				<Pou name="OCT_TO_BYTE"/>
				<Pou name="TO_UPPER"/>
				<Pou name="TO_LOWER"/>
				<Pou name="TICKER"/>
			</folder>
		</libWorkspace>
		<globalVars/>
		<retainVars/>
		<constantVars/>
		<functions>
			<function name="BIN_TO_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="BIN" type="STRING" length="12"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.2	26. jul 2009
programmer 	hugo
tested by		oscat

BINARY_TO_byte converts a binary string into a byte.

*)

pt := ADR(bin);
stop := LEN(bin);
FOR I := 1 TO stop DO
	x := @pt;
	(* calculate the value of the digit *)
	IF X = 48 THEN
		BIN_TO_BYTE := SHL(BIN_TO_BYTE,1);
	ELSIF X = 49 THEN
		BIN_TO_BYTE := SHL(BIN_TO_BYTE,1) OR 1;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep. 2008	rev 1.1
	changed length of input string from 20 to 12

hm	26. jul. 2009	rev 1.2
	optimized code
*)	

]]>
				</sourceCode>
			</function>
			<function name="BIN_TO_DWORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="BIN" type="STRING" length="40"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.2	26. jul. 2009
programmer 	hugo
tested by		oscat

BINARY_TO_DWORD converts a binary string into a dword.

*)

pt := ADR(bin);
stop := LEN(bin);
FOR I := 1 TO stop DO
	x := @pt;
	(* calculate the value of the digit *)
	IF X = 48 THEN
		BIN_TO_DWORD := SHL(BIN_TO_DWORD,1);
	ELSIF X = 49 THEN
		BIN_TO_DWORD := SHL(BIN_TO_DWORD,1) OR 1;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep. 2008	rev 1.1
	changed length of input dtring from 20 to 40

hm	26. jul 2009	rev 1.2
	optimized code
*)	

]]>
				</sourceCode>
			</function>
			<function name="CHARCODE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="STR" type="STRING" length="10"/>
					</inputVars>
					<localVars>
						<var name="found" type="STRING" length="1"/>
						<var name="search" type="STRING" length="10"/>
						<var name="pos" type="INT"/>
						<var name="i" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.2		24. oct. 2008
programmer 		hugo
tested by		hugo

CHARCODE converts a HTML Character NAME INTO ITS code
'äuml' is convterted to ä
'euro' is converted to €

*)

IF LEN(str) = 1 THEN
	CHARCODE := CODE(STR, 1);
ELSIF str <> '' THEN
	(* construct search string *)
	search := CONCAT('&', str);
	search := CONCAT(search, ';');
	WHILE pos = 0 AND (i < 4) DO
		i := i + 1;
		pos := FIND(setup.CHARNAMES[i], search);
	END_WHILE;
	found := MID(setup.CHARNAMES[i], 1, pos - 1);
	CHARCODE := CODE(found, 1);
END_IF;




(* revision history
hm	13. may. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changed setup constants

hm	24. oct. 2008	rev 1.2
	optimized code
*)

]]>
				</sourceCode>
			</function>
			<function name="FINDB_NONUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	pos: INT;
	pt : @BYTE;
END_VAR

(*
version 1.3	21. oct. 2008
programmer 	hugo
tested by	oscat

findB_noNum searches str backwards and returns the last position which is not a number.
a number is characterized by a letter 0..9 or .

*)

pt := ADR(str) + LEN(str) - 1;
FOR pos := LEN(str) TO 1 BY -1 DO;
	IF (@PT < 48 AND @PT <> 46) OR @PT > 57 THEN
		FINDB_NONUM := pos;
		RETURN;
	END_IF;
	PT := PT - 1;
END_FOR;
FINDB_NONUM := 0;


(* revision history
hm	6. oct 2006		rev 1.0
	original version

hm	29. feb 2008	rev 1.1
	improved performance

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)

hm	21. oct. 2008	rev 1.3
	optimized code
*)
]]>
				</sourceCode>
			</function>
			<function name="FIND_NONUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	pos : INT;
END_VAR
VAR
	i: INT;
	pt : @BYTE;
	end: INT;
	X: BYTE;
END_VAR

(*
version 1.3	21. oct. 2008
programmer 	hugo
tested by	tobias

find_noNum searches str and returns the first position which is not a number.
a number is characterized by a letter 0..9 or .

*)

pt := ADR(str);
end := LEN(str);
FOR i := MAX(pos,1) TO end DO;
	X := @pt[i];
	IF (X < 48 AND X <> 46) OR X > 57 THEN
		FIND_NONUM := i;
		RETURN;
	END_IF;
END_FOR;
FIND_NONUM := 0;


(* revision history
hm	6. oct. 2006	rev 1.0
	original version

hm	29. feb 2008	rev 1.1
	added input pos to start search at position

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)

hm	21. oct. 2008	rev 1.3
	optimized code

*)
]]>
				</sourceCode>
			</function>
			<function name="FIND_NUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	pos : INT;
END_VAR
VAR
	i : INT;
	pt : @BYTE;
	stop : INT;
	X: BYTE;
END_VAR

(*
version 1.2	29. mar. 2008
programmer 	hugo
tested by		tobias

find_Num searches str and returns the starting position of a number
a number is characterized by a letter 0..9 or .

*)

pt := ADR(str);
stop := LEN(str);
FOR i := MAX(pos,1) TO stop DO;
	X := @pt[i];
	IF (X > 47 AND X < 58) OR X = 46 THEN
		FIND_NUM := i;
		RETURN;
	END_IF;
END_FOR;
FIND_NUM := 0;


(* revision history
hm	6. oct. 2006	rev 1.0
	original version

hm	29. feb 2008	rev 1.1
	added input pos to start search at position

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)

*)
]]>
				</sourceCode>
			</function>
			<function name="FINDB_NUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	pos: INT;
	pt : @BYTE;
END_VAR

(*
version 1.2	29. mar. 2008
programmer 	hugo
tested by	tobias

findB_Num searches str backward and returns the last position of a number
a number is characterized by a letter 0..9 or .

*)

pt := ADR(str) + LEN(str) - 1;
FOR pos := LEN(str) TO 1 BY -1 DO;
	IF (@PT > 47 AND @PT < 58) OR @PT = 46 THEN
		FINDB_NUM := pos;
		RETURN;
	END_IF;
	PT := PT - 1;
END_FOR;
FINDB_NUM := 0;

(* revision history
hm	6. oct 2006		rev 1.0
	original version

hm	29. feb 2008	rev 1.1
	improved performance

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="FINDB" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str1 : STRING[STRING_LENGTH];
	str2 : STRING[STRING_LENGTH];
END_VAR
VAR
	pos: INT;
	length: INT;
END_VAR

(*
version 1.3	29. mar. 2008
programmer 	hugo
tested by		tobias

the function find searches an str1 for the presence of str2 and returns the first position of str1 of the last presence in instring.
the function is similar to find except it searches from the right to left.
 a 0 is returned if the string is not found.

*)

length := LEN(str2);
FOR pos := LEN(str1) - length + 1 TO 1 BY -1 DO
	IF MID(str1,length,pos) = str2 THEN
		FindB := pos;
		RETURN;
	END_IF;
END_FOR;
FindB := 0;

(* revision history
hm	6. oct 2006		rev 1.0
	original version

hm	15 dec 2007		rev 1.1
	changed code for better performance

hm	29. feb 2008	rev 1.2
	added findb := 0 for compatibility reasons

hm	29. mar. 2008	rev 1.3
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="FIND_CHAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	pos : INT;
END_VAR
VAR
	i: INT;
	pt : @BYTE;
	stop: INT;
	X: BYTE;
END_VAR

(*
version 1.3	21. oct. 2008
programmer 	hugo
tested by	tobias

find_char searches str and returns the starting position of the first character that is not a control character.
control characters are the ascii character 00 .. 31 and 127

*)

pt := ADR(str);
stop := LEN(str);
FOR i := MAX(pos,1) TO stop DO;
	X := @pt[i];
	IF X > 31 AND ((setup.EXTENDED_ASCII AND X <> 127) OR (NOT setup.EXTENDED_ASCII AND X < 127)) THEN
		FIND_CHAR := i;
		RETURN;
	END_IF;
END_FOR;
FIND_CHAR := 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	26. mar. 2008	rev 1.1
	char will now accept extended ascii

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)

hm	21. oct. 2008	rev 1.3
	changes setup constants
	optimized code
*)


]]>
				</sourceCode>
			</function>
			<function name="FIND_CTRL" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	pos : INT;
END_VAR
VAR
	i: INT;
	pt : @BYTE;
	stop: INT;
	x: BYTE;
END_VAR

(*
version 1.2	29. mar. 2008
programmer 	hugo
tested by		tobias

find_ctrl searches str and returns the starting position of a control character
control characters are the ascii character 00 .. 31 and 127.

*)

pt := ADR(str);
stop := LEN(str);
FOR i := MAX(pos,1) TO stop DO;
	x := @PT[I];
	IF x < 32 OR X = 127 THEN
		FIND_CTRL := i;
		RETURN;
	END_IF;
END_FOR;
FIND_CTRL := 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	26. mar. 2008	rev 1.1
	character 127 is now recognized as control

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="CODE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	STR : STRING[STRING_LENGTH];
	POS : INT;
END_VAR
VAR
	PT : @BYTE;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 	hugo
tested by		tobias

code extracts the code of a character at position POS of a string STR.

*)

IF pos < 1 OR pos > LEN(str) THEN
	CODE := 0;
	RETURN;
ELSE
	PT := ADR(STR) + TO_DWORD(pos - 1);
	CODE := @pt;
END_IF;

(* revision history
hm	9. mar. 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="COUNT_CHAR" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	chr : BYTE;
END_VAR
VAR
	l: INT;
	pt : @BYTE;
	pos: INT;
END_VAR


(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

COUNT_CHAR counts how often a character CHAR occurs within a string STR.

*)

PT := ADR(str);
l := LEN(str);
COUNT_CHAR := 0;
FOR pos := 1 TO l DO
	IF @pt = CHR THEN COUNT_CHAR := COUNT_CHAR + 1; END_IF;
    PT := PT + 1;
END_FOR;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="DEC_TO_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="DEC" type="STRING" length="10"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	30. sep 2008
programmer 	hugo
tested by		oscat

DEC_TO_byte converts a decimal string into a byte.

*)

pt := ADR(dec);
stop := LEN(DEC);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 58 THEN
		DEC_TO_BYTE := DEC_TO_BYTE * 10 + X - 48;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	20. jun. 2008	rev 1.0
	original release

hm	30. sep.2008	rev 1.1
	changed length of input string from 20 to 10
	corrected an error where decoding of characters 8 and 9 would fail

*)	

]]>
				</sourceCode>
			</function>
			<function name="DEC_TO_DWORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="DEC" type="STRING" length="20"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	30. sep. 2008
programmer 	hugo
tested by		oscat

DEC_TO_DWORD converts a decimal string into a DWORD.

*)

pt := ADR(dec);
stop := LEN(dec);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 58 THEN
		DEC_TO_DWORD := DEC_TO_DWORD * 10 + X - 48;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	20. jun. 2008	rev 1.0
	original release

hm	30. sep. 2008	rev 1.1
	corrected an error where decoding of characters 8 and 9 would fail
*)	

]]>
				</sourceCode>
			</function>
			<function name="DEC_TO_INT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="DEC" type="STRING" length="10"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="sign" type="BOOL"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	30. sep. 2008
programmer 	hugo
tested by	oscat

DEC_TO_INT converts a decimal string into an Integer.

*)

pt := ADR(dec);
stop := LEN(dec);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 58 THEN
		DEC_TO_INT := DEC_TO_INT * 10 + X - 48;
	ELSIF X = 45 AND DEC_TO_INT = 0 THEN
		sign := TRUE;
	END_IF;
	pt := pt + 1;
END_FOR;
IF sign THEN DEC_TO_INT := -DEC_TO_INT; END_IF;


(* revision histroy
hm	20. jun. 2008	rev 1.0
	original release

hm	30. sep. 2008	rev 1.1
	changed length of input string from 20 to 10
	corrected an error where decoding of characters 8 and 9 would fail
*)	

]]>
				</sourceCode>
			</function>
			<function name="DT_TO_STRF" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue length="32">STRING</returnValue>
				<vars>
					<inputVars>
						<var name="DTI" type="DATE_AND_TIME"/>
						<var name="MS" type="INT"/>
						<var name="FMT" type="STRING" length="0"/>
						<var name="LANG" type="INT"/>
					</inputVars>
					<localVars>
						<var name="FILL" type="STRING" length="1"/>
						<var name="BLANK" type="STRING" length="1"/>
						<var name="ly" type="INT"/>
						<var name="dx" type="DATE"/>
						<var name="fs" type="STRING" length="10"/>
						<var name="td" type="TIME_OF_DAY"/>
						<var name="tmp" type="INT"/>
						<var name="pos" type="INT"/>
						<var name="f" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	19. oct. 2008
programmer 	hugo
tested by	oscat

DT_TO_STRINGF converts a DATETIME input to a formatted string

*)

IF LANG < 1 THEN ly := language.DEFAULT; ELSE ly := MIN(language.LMAX, LANG); END_IF;

(* decode date and time information *)
dx := DT_TO_DATE(DTI);
td := DT_TO_TOD(DTI);

(* parse the format string *)
DT_TO_STRF := FMT;
pos := FIND(DT_TO_STRF, '#');
WHILE pos > 0 DO
	(* retrieve format identifier *)
	f := CODE(DT_TO_STRF, pos + 1);
	(* generate the return string according to the format character *)
	fs := '';
	CASE f OF
		65 : (* letter A retunrs the year in 4 digits *)
			fs := INT_TO_STRING(YEAR_OF_DATE(dx));
		66 : (* letter B returns the year in exactly 2 digits *)
			fs := RIGHT(INT_TO_STRING(YEAR_OF_DATE(dx)),2);
		67 : (* letter C returns the month with 1 or 2 digits *)
			fs := INT_TO_STRING(MONTH_OF_DATE(dx));
		68 : (* letter D returns the month with exactly 2 digits *)
			fs := INT_TO_STRING(MONTH_OF_DATE(dx));
			IF LEN(fs) < 2 THEN fs := CONCAT('0', fs); END_IF;
		69 : (* letter E returns the month with 3 characters *)
			fs := MONTH_TO_STRING(MONTH_OF_DATE(dx), ly, 3);
		70 : (* letter F returns the month with all characters *)
			fs := MONTH_TO_STRING(MONTH_OF_DATE(dx), ly, 0);
		71 : (* letter G returns the day with up to 2 digits *)
			fs := INT_TO_STRING(DAY_OF_MONTH(dx));
		72 : (* letter H returns the day of the month with exactly 2 digits *)
			fs := INT_TO_STRING(DAY_OF_MONTH(dx));
			IF LEN(fs) < 2 THEN fs := CONCAT(FILL, fs); END_IF;
		73 : (* letter I returns the weekday as the number 1..7 1 = monday *)
			fs := INT_TO_STRING(DAY_OF_WEEK(dx));
		74 : (* letter J returns the weekday in 2 character writing *)
			fs := WEEKDAY_TO_STRING(DAY_OF_WEEK(dx), ly, 2);
		75 : (* letter K returns the weekday with all characters *)
			fs := WEEKDAY_TO_STRING(DAY_OF_WEEK(dx), ly, 0);
		76 : (* letter L returns AM or PM for the given DateTime *)
			IF td >= TOD#12:00 THEN fs := 'PM'; ELSE fs := 'AM'; END_IF;
		77 : (* letter M returns the hour in 1 or 2 digit form 0..24h *)
			fs := INT_TO_STRING(HOUR(td));
		78 : (* letter N returns the hour in exactly 2 digit form 0..24h *)
			fs := INT_TO_STRING(HOUR(td));
			IF LEN(fs) < 2 THEN fs := CONCAT(FILL, fs); END_IF;
		79 : (* letter O returns the hour in 1 or 2 digit form 0..12h *)
			tmp := HOUR(td) MOD 12;
			IF tmp = 0 THEN tmp := 12; END_IF;
			fs := INT_TO_STRING(tmp);
		80 : (* letter P returns the hour in exactly 2 digit form 0..12h *)
			tmp := HOUR(td) MOD 12;
			IF tmp = 0 THEN tmp := 12; END_IF;
			fs := INT_TO_STRING(tmp);
			IF LEN(fs) < 2 THEN fs := CONCAT(FILL, fs); END_IF;
		81 : (* letter Q returns the minute of the hour in 1 or two digit form *)
			fs := INT_TO_STRING(MINUTE(td));
		82 : (* letter R returns the minute of the hour in exactly two digit form *)
			fs := INT_TO_STRING(MINUTE(td));
			IF LEN(fs) < 2 THEN fs := CONCAT(FILL, fs); END_IF;
		83 : (* letter S returns the second of the minute in 1 or two digit form *)
			fs := INT_TO_STRING(TO_INT(SECOND(td)));
		84 : (* letter T returns the second of the minute in exactly two digit form *)
			fs := INT_TO_STRING(TO_INT(SECOND(td)));
			IF LEN(fs) < 2 THEN fs := CONCAT(FILL, fs); END_IF;
		85 : (* letter U returns the milliseconds in 1 to 3 digits *)
			fs := INT_TO_STRING(MS);
		86 : (* letter V returns the milliseconds in exactly 3 digit form *)
			fs := INT_TO_STRING(MS);
			fs := CONCAT('00',fs);
			fs := RIGHT(fs, 3);
		87 : (* letter W returns the day of the month with exactly 2 digits first digit is filled with blank if necessary *)
			fs := INT_TO_STRING(DAY_OF_MONTH(dx));
			IF LEN(fs) < 2 THEN fs := CONCAT(BLANK, fs); END_IF;
		88 : (* letter X returns the month with exactly 2 digits first digit is filled with blank if necessary *)
			fs := INT_TO_STRING(MONTH_OF_DATE(dx));
			IF LEN(fs) < 2 THEN fs := CONCAT(BLANK, fs); END_IF;
		END_CASE;
	DT_TO_STRF := REPLACE(DT_TO_STRF, fs, 2, pos);
	pos := FIND(DT_TO_STRF, '#');
END_WHILE;


(* revision history
hm	7. oct. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changed language setup constants
*)

]]>
				</sourceCode>
			</function>
			<function name="DWORD_OF_WORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="W1" type="WORD"/>
						<var name="W0" type="WORD"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	18. jul. 2009
programmer 	hugo
tested by		tobias

this function creates a Dword from 2 individual Words

*)

DWORD_OF_WORD := SHL(TO_DWORD(W1),16) OR TO_DWORD(W0);


(* revision history

hm	18. jul. 2009	rev 1.0
	original version

*)
]]>
				</sourceCode>
			</function>
			<function name="DWORD_OF_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="B3" type="BYTE"/>
						<var name="B2" type="BYTE"/>
						<var name="B1" type="BYTE"/>
						<var name="B0" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.3	18. jul. 2009
programmer 	hugo
tested by		tobias

this function creates a Dword from 4 individual bytes

*)

DWORD_OF_BYTE := SHL(SHL(SHL(TO_DWORD(B3),8) OR TO_DWORD(B2),8) OR TO_DWORD(B1),8) OR TO_DWORD(B0);


(* revision history
hm	24. jan 2007	rev 1.0
	original version

hm 2. jan 2008	rev 1.1
	inproved performance

hm	23. apr. 2008	rev 1.2
	reverse order of inputs to be more logical

hm	18. jul. 2009	rev 1.3
	added type conversions for compatibility reasons
*)
]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_WEEK" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="WEEK" type="STRING" length="60"/>
						<var name="LANG" type="INT"/>
					</inputVars>
					<localVars>
						<var name="pos" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	25. oct. 2008
programmer 	hugo
tested by	oscat

FSTRING_TO_WEEK converts a list of weekdays into a byte where each bit represents a day of the week.
bit 6 = mo, 0 = su;

*)

pos := FIND(WEEK, ',');
WHILE pos > 0 DO
	FSTRING_TO_WEEK := FSTRING_TO_WEEK OR SHR(BYTE#128, FSTRING_TO_WEEKDAY(MID(WEEK, pos - 1, 1), LANG));
	WEEK := RIGHT(WEEK, LEN(Week) - pos);
	pos := FIND(WEEK, ',');
END_WHILE;
FSTRING_TO_WEEK := (FSTRING_TO_WEEK OR SHR(BYTE#128, FSTRING_TO_WEEKDAY(WEEK, LANG))) AND BYTE#127;


(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	25. oct. 2008	rev 1.1
	using language defauls and input lang
*)	

]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_MONTH" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="MTH" type="STRING" length="20"/>
						<var name="LANG" type="INT"/>
					</inputVars>
					<localVars>
						<var name="lx" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.2	25. oct 2008
programmer 	hugo
tested by	oscat

FSTRING_TO_MONTH converts a string into a month, the string can be a name for the month or a number.
the function is language sensitve when LANG > 1 and checks for all languages when LANG = 0

*)

IF LANG = 0 THEN lx := LANGUAGE.DEFAULT; ELSE lx := MIN(LANG, LANGUAGE.LMAX); END_IF;
MTH := TRIM(mth);
MTH := CAPITALIZE(LOWERCASE(MTH));

FOR FSTRING_TO_MONTH := 1 TO 12 DO
	IF MTH = language.MONTHS[lx, FSTRING_TO_MONTH] THEN RETURN; END_IF;
	IF MTH = language.MONTHS3[lx, FSTRING_TO_MONTH] THEN RETURN; END_IF;
END_FOR;

(* since no name matched try to decode as integer *)
FSTRING_TO_MONTH := STRING_TO_INT(MTH);




(* revision histroy
hm	25. sep. 2008	rev 1.0
	original release

hm	19. oct. 2008	rev 1.1
	changed language setup constants

hm	25. oct. 2008	rev 1.2
	optimized code
*)	

]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_WEEKDAY" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars>
					<inputVars>
						<var name="WDAY" type="STRING" length="20"/>
						<var name="LANG" type="INT"/>
					</inputVars>
					<localVars>
						<var name="tmp" type="STRING" length="2"/>
						<var name="i" type="INT"/>
						<var name="ly" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.2	25. oct. 2008
programmer 	hugo
tested by	oscat

FSTRING_TO_WEEKDAY converts a weekday string into an integer 1..7.

*)

IF LANG = 0 THEN ly := LANGUAGE.DEFAULT; ELSE ly := MIN(LANG, LANGUAGE.LMAX); END_IF;
(* tmp needs to be calculated first otherwise find can return wrong values *)
tmp := TRIM(wday);
tmp := CAPITALIZE(LOWERCASE(tmp));
FOR i := 1 TO 7 DO
	IF language.WEEKDAYS2[ly, i] = tmp THEN
		FSTRING_TO_WEEKDAY := i;
		RETURN;
	END_IF;
END_FOR;
FSTRING_TO_WEEKDAY := STRING_TO_INT(WDAY);




(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	18. jul. 2008	rev 1.1
	changed nested call of left(trim()) for compatibility reasons

hm	25. oct. 2008	rev 1.2
	using language constants
*)	

]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_DWORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="STRING" length="40"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	20. sep. 2008
programmer 	hugo
tested by		oscat

FSTRING_TO_BYTE converts a formatted string into a byte.
the string can be of the form 2#01010, 8#7234, 16#2AD3 and 1234

*)

IF LEFT(IN, 2) = '2#' THEN
	(* we need to convert binary *)
	FSTRING_TO_DWORD := BIN_TO_DWORD(RIGHT(in, LEN(in) - 2));
ELSIF LEFT(in, 2) = '8#' THEN
	(* weneed to convert octals *)
	FSTRING_TO_DWORD := OCT_TO_DWORD(RIGHT(in, LEN(in) - 2));
ELSIF LEFT(in, 3) = '16#' THEN
	(* we need to convert hexadecimal *)
	FSTRING_TO_DWORD := HEX_TO_DWORD(RIGHT(in, LEN(in) - 3));
ELSE
	(* we assume decimal representation *)
	FSTRING_TO_DWORD := DEC_TO_DWORD(CLEAN(in,'0123456789'));
END_IF;


(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep. 2008	rev 1.1
	changed length of input dtring from 20 to 40


*)	

]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_DT" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DATE_AND_TIME</returnValue>
				<vars>
					<inputVars>
						<var name="SDT" type="STRING" length="60"/>
						<var name="FMT" type="STRING" length="60"/>
					</inputVars>
					<localVars>
						<var name="ignore" type="STRING" length="1">
							<descr>ignore character is *</descr>
						</var>
						<var name="fchar" type="STRING" length="1">
							<descr>format character is #</descr>
						</var>
						<var name="c" type="STRING" length="1"/>
						<var name="tmp" type="STRING" length="20"/>
						<var name="end" type="INT"/>
						<var name="dy" type="INT"/>
						<var name="dm" type="INT"/>
						<var name="dd" type="INT"/>
						<var name="th" type="INT"/>
						<var name="tm" type="INT"/>
						<var name="ts" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	24. sep. 2008
programmer 	hugo
tested by	oscat

FSTRING_TO_DT converts Formatted String into a DT value.

*)

(* scan input string *)
WHILE fmt <> '' DO
	c := LEFT(fmt,1);
	IF c = ignore THEN
		(* skip ignore characters *)
		fmt := DELETE(fmt,1,1);
		sdt := DELETE(sdt,1,1);
	ELSIF C = fchar THEN
		(* format chracter found skip format char and read identifier *)
		(* store format identifier in c and skip to next char in fmt *)
		c := MID(fmt,1,2);
		fmt := DELETE(fmt,2,1);
		(* extract the substring until the end of sdt or to next char of fmt *)
		IF fmt = '' THEN
			tmp := sdt;
		ELSE
			(* serach for end of substring *)
			end := FIND(sdt, LEFT(fmt,1))-1;
			tmp := LEFT(sdt, end);
			sdt := DELETE(sdt, end,1);
		END_IF;
		(* extract information from substring *)
		IF c = 'Y' THEN
			dy := STRING_TO_INT(tmp);
			IF dy < 100 THEN dy := dy + 2000; END_IF;
		ELSIF c = 'M' THEN
			dm := STRING_TO_INT(tmp);
		ELSIF c = 'N' THEN
			dm := FSTRING_TO_MONTH(tmp,0);
		ELSIF c = 'D' THEN
			dd := STRING_TO_INT(tmp);
		ELSIF c = 'h' THEN
			th := STRING_TO_INT(tmp);
		ELSIF c = 'm' THEN
			tm := STRING_TO_INT(tmp);
		ELSIF c = 's' THEN
			ts := STRING_TO_INT(tmp);
		END_IF;
	ELSIF c = LEFT(sdt,1) THEN
		(* skip matching characters *)
		fmt := DELETE(fmt,1,1);
		sdt := DELETE(sdt,1,1);
	ELSE
		RETURN;
	END_IF;
END_WHILE;

FSTRING_TO_DT := SET_DT(dy,dm,dd,th,tm,ts);


(* revision histroy
hm	24. sep. 2008	rev 1.0
	original release


*)	

]]>
				</sourceCode>
			</function>
			<function name="FSTRING_TO_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="STRING" length="12"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	20. sep. 2008
programmer 	hugo
tested by		oscat

FSTRING_TO_BYTE converts a formatted string into a byte.
the string can be of the form 2#01010, 8#7234, 16#2AD3 and 1234

*)

IF LEFT(IN, 2) = '2#' THEN
	(* we need to convert binary *)
	FSTRING_TO_BYTE := BIN_TO_BYTE(RIGHT(in, LEN(in) - 2));
ELSIF LEFT(in, 2) = '8#' THEN
	(* weneed to convert octals *)
	FSTRING_TO_BYTE := OCT_TO_BYTE(RIGHT(in, LEN(in) - 2));
ELSIF LEFT(in, 3) = '16#' THEN
	(* we need to convert hexadecimal *)
	FSTRING_TO_BYTE := HEX_TO_BYTE(RIGHT(in, LEN(in) - 3));
ELSE
	(* we assume decimal representation *)
	FSTRING_TO_BYTE := DEC_TO_BYTE(CLEAN(in,'0123456789'));
END_IF;


(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep. 2008	rev 1.1
	changed length of input string from 20 to 12
*)	

]]>
				</sourceCode>
			</function>
			<function name="IS_CTRL" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	STR : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar 2008
programmer 		kurt
tested by		hugo

IS_CTRL testet ob in einem string nur Steuerzeichen (Char < 32) vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_CTRL(@pt)) THEN
		IS_CTRL := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_CTRL := L > 0;


(* revision history
hm	29. feb. 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_NUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	6. mar 2008
programmer 	oscat
tested by		hugo

ISC_NUM checks if a character is 0..9.

*)

ISC_NUM := IN > 47 AND IN < 58;

(* revision history
hm		6. mar. 2008	rev 1.0
	original version

*)
]]>
				</sourceCode>
			</function>
			<function name="IS_CC" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	cmp : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 	Tobias
tested by	hugo

ISC_CC testet ob ein string nur aus Zeichen des Strings CMP besteht.

*)

L := LEN(str);
FOR pos := 1 TO L DO
	IF FIND(CMP,MID(str,1,pos)) = 0 THEN RETURN; END_IF;
END_FOR;
IS_CC := L > 0;



(* revision history
hm	19. mar 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_CTRL" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	6. mar 2008
programmer 	oscat
tested by		hugo

ISC_ALPHA checks if a character is a control character.

*)

ISC_CTRL := IN < 32 OR IN = 127;

(* revision history
hm		6. mar. 2008	rev 1.0
	original version

*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_UPPER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	19. oct. 2008
programmer 	hugo
tested by	oscat

ISC_upper checks if a character is uppercase

*)

IF setup.EXTENDED_ASCII THEN
	ISC_UPPER :=  ((in > 64) AND (in < 91)) OR (((in > 191) AND (in < 223)) AND (in <> 215));
ELSE
	ISC_UPPER := ((in > 64) AND (in < 91));
END_IF;


(* revision history
hm	6. mar. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changes setup constants

*)
]]>
				</sourceCode>
			</function>
			<function name="IS_UPPER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

IS_UPPER testet ob in einem string keine Kleinbuchstaben vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_UPPER(@pt)) THEN
		IS_UPPER := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_UPPER := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="IS_ALPHA" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

IS_ALPHA testet ob in einem string nur Zeichen a-z oder A - Z vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT ISC_ALPHA(@pt) THEN
		IS_ALPHA := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_ALPHA := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_LOWER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	19. oct. 2008
programmer 	hugo
tested by	oscat

isc_lower checks if a character is lowercase.

*)

IF setup.EXTENDED_ASCII THEN
	ISC_LOWER := ((in > 96) AND (in < 123)) OR ((in > 222) AND (in <> 247));
ELSE
	ISC_LOWER := ((in > 96) AND (in < 123));
END_IF;

(* revision history
hm	6. mar. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changes setup constants
*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_ALPHA" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.1	19. oct. 2008
programmer 	oscat
tested by	oscat

ISC_ALPHA checks if a character is a..z or A..Z.

*)

IF setup.EXTENDED_ASCII THEN
	ISC_ALPHA := (in > 64 AND in < 91) OR (in > 191  AND in <> 215 AND in <> 247) OR (in > 96 AND in < 123);
ELSE
	ISC_ALPHA := (IN > 64 AND IN < 91) OR (in > 96 AND in < 123);
END_IF;

(* revision history
hm	6. mar. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changes setup constants
*)

]]>
				</sourceCode>
			</function>
			<function name="IS_NUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	L : INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

IS_NUM testet ob in einem string nur Zahlen 0..9 vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_NUM(@pt)) THEN
		IS_NUM := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_NUM := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="IS_NCC" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	cmp : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 	Tobias
tested by		hugo

IS_NCC testet ob in einem string keine Zeichen des Strings CMP enthalten sind.

*)

L := LEN(str);
FOR pos := 1 TO L DO
	IF FIND(CMP,MID(str,1,pos)) > 0 THEN RETURN; END_IF;
END_FOR;
IS_NCC := TRUE;



(* revision history
hm	19. mar 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="IS_LOWER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	l: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

IS_LOWER testet ob in einem string nur kleinbuchstaben vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_LOWER(@pt)) THEN
		IS_LOWER := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_LOWER := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="IS_HEX" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

IS_HEX testet ob in einem string nur Zahlen 0..9 oder A..F oder a..f  vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_HEX(@pt)) THEN
		IS_HEX := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_HEX := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="ISC_HEX" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.0	6. mar 2008
programmer 	oscat
tested by		hugo

ISC_HEX checks if a character is 0..9, A..F, a..f.

*)

ISC_HEX := (IN > 47 AND IN < 58) OR (IN > 64 AND IN < 71) OR (IN > 96 AND IN < 103);

(* revision history
hm		6. mar. 2008	rev 1.0
	original version

*)
]]>
				</sourceCode>
			</function>
			<function name="IS_ALNUM" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BOOL</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
END_VAR
VAR
	L: INT;
	pt : @BYTE;
	pos: INT;
END_VAR

(*
version 1.1	29. mar. 2008
programmer 		kurt
tested by		hugo

ISC_ALNUM testet ob in einem string nur Zahlen 0..9 vorkommen.

*)

PT := ADR(str);
L := LEN(str);
FOR pos := 1 TO L DO
	IF NOT (ISC_ALPHA(@pt) OR ISC_NUM(@pt)) THEN
		IS_ALNUM := FALSE;
		RETURN;
	END_IF;
    	PT := PT + 1;
END_FOR;
IS_ALNUM := L > 0;


(* revision history
hm	29. feb 2008	rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</function>
			<function name="FINDP" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>INT</returnValue>
				<vars/>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	str : STRING[STRING_LENGTH];
	src : STRING[STRING_LENGTH];
	pos: INT;
END_VAR
VAR
	i: INT;
	ls: INT;
	lx: INT;
	stp: INT;
END_VAR

(*
version 1.2	29. mar. 2008
programmer 	hugo
tested by	tobias

the function findP searches a string str for the occurence of src beginning at the position pos.

*)

ls := LEN(str);
lx := LEN(src);
IF ls < lx OR lx = 0 THEN RETURN; END_IF;
stp := ls - lx + 1;
FOR i := MAX(pos,1) TO stp DO
	IF MID(str,lx,i) = src THEN
		FINDP := i;
		RETURN;
	END_IF;
END_FOR;
FINDP := 0;

(* revision histroy
hm	4. feb. 2008	rev 1.0
	original release

hm	29. feb 2008	rev 1.1
	ADDED MAX(pos,1) in loop initialization

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)
*)	

]]>
				</sourceCode>
			</function>
			<function name="FLOAT_TO_REAL" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>REAL</returnValue>
				<vars>
					<inputVars>
						<var name="FLT" type="STRING" length="20"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="sign" type="INT"/>
						<var name="stop" type="INT"/>
						<var name="tmp" type="DINT"/>
						<var name="d" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.3	23. oct. 2008
programmer 	hugo
tested by	oscat

FLOAT_TO_REAL converts a string to a REAL.
the function ignores all wrong characters.
the comma can be , or .
the exponent has to start with capital E or lowercase e .


*)

pt := ADR(FLT);
stop := LEN(FLT);

(* we first check for sign and exit if first number or dot is reached *)
FOR i := 1 TO stop DO
	X := @pt[i];
	IF X > 47 AND X < 58 OR X = 46 THEN
		EXIT;
	ELSIF X = 45 THEN
		(* code 45 is sign *)
		sign := -1;
	END_IF;
END_FOR;

(* now we scan numbers till end or dot or E is reached *)
FOR i := i TO stop DO
	X := @pt[i];
	IF X = 44 OR X = 46 OR X = 69 OR X = 101 THEN
		EXIT;
	(* calculate the value of the digit *)
	ELSIF X > 47 AND x < 58 THEN
		tmp := tmp * 10 + X - 48;
	END_IF;
END_FOR;

(* process the portion after the comma if comma or dot is reached exit if exponent starts *)
IF x = 44 OR X = 46 THEN
	FOR i := i + 1 TO stop DO
		X := @pt[i];
		IF X = 69 OR X = 101 THEN
			EXIT;
		ELSIF x > 47 AND x < 58 THEN
			tmp := tmp * 10 + X - 48;
			d := d - 1;
		END_IF;
	END_FOR;
END_IF;

(* process exponent if present *)
IF X = 69 OR X = 101 THEN
	d := d + DEC_TO_INT(RIGHT(FLT, stop - i));
END_IF;

FLOAT_TO_REAL :=  EXPN(10, d) * TO_REAL(TMP * SIGN);




(* revision histroy
hm	22. jun. 2008	rev 1.0
	original release

hm	2. oct. 2008	rev 1.1
	fixed an error, characters 8 and 9 would not be converted

hm	22. oct. 2008	rev 1.2
	last fix was not done correctly

hm	23. oct. 2008	rev 1.3
	optimzed code
*)	

]]>
				</sourceCode>
			</function>
			<function name="HEX_TO_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="HEX" type="STRING" length="5"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	20. sep. 2008
programmer 	hugo
tested by		oscat

HEX_TO_BYTE converts a Hexadecimal string into a byte.

*)

pt := ADR(hex);
stop := LEN(hex);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 58 THEN
		HEX_TO_BYTE := SHL(HEX_TO_BYTE,4) + X - 48;
	ELSIF X > 64 AND X < 71 THEN
		HEX_TO_BYTE := SHL(HEX_TO_BYTE,4) + X - 55;
	ELSIF X > 96 AND X < 103 THEN
		HEX_TO_BYTE := SHL(HEX_TO_BYTE,4) + X - 87;
	END_IF;
	pt := pt + 1;
END_FOR;




(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep.2008	rev 1.1
	changed length of input string from 20 to 5

*)	

]]>
				</sourceCode>
			</function>
			<function name="HEX_TO_DWORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="Hex" type="STRING" length="20"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.4	18. jun. 2008
programmer 	hugo
tested by	tobias

HEX_TO_DWORD converts a Hexadecimal string into a DWORD.

*)

pt := ADR(hex);
stop := LEN(hex);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 58 THEN
		HEX_TO_DWORD := SHL(HEX_TO_DWORD,4) + X - 48;
	ELSIF X > 64 AND X < 71 THEN
		HEX_TO_DWORD := SHL(HEX_TO_DWORD,4) + X - 55;
	ELSIF X > 96 AND X < 103 THEN
		HEX_TO_DWORD := SHL(HEX_TO_DWORD,4) + X - 87;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	2.10.2007		rev 1.0
	original release

hm	19.11.2007		rev 1.1
	changed type of function from int to dword

hm 	4. mar 2008		rev 1.2
	added support for a..f and return 0 for invalid string

hm	29. mar. 2008	rev 1.3
	changed STRING to STRING(8)

hm	18. jun. 2008	rev 1.4
	changed input hex to STRING(20)
	function now ignores wrong characters
*)	

]]>
				</sourceCode>
			</function>
			<function name="OCT_TO_DWORD" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>DWORD</returnValue>
				<vars>
					<inputVars>
						<var name="OCT" type="STRING" length="20"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.0	18. jun 2008
programmer 	hugo
tested by	oscat

OCT_TO_DWORD converts a octagonal string into a dword.

*)

pt := ADR(oct);
stop := LEN(oct);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 56 THEN
		OCT_TO_DWORD := SHL(OCT_TO_DWORD,3) + X - 48;
	END_IF;
	pt := pt + 1;
END_FOR;




(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release


*)	

]]>
				</sourceCode>
			</function>
			<function name="OCT_TO_BYTE" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="OCT" type="STRING" length="10"/>
					</inputVars>
					<localVars>
						<var name="pt" type="@BYTE"/>
						<var name="i" type="INT"/>
						<var name="X" type="BYTE"/>
						<var name="stop" type="INT"/>
					</localVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[

(*
version 1.1	20. sep. 2008
programmer 	hugo
tested by		oscat

OCT_TO_BYTE converts a octagonal string into a byte.

*)

pt := ADR(oct);
stop := LEN(oct);
FOR I := 1 TO stop DO
	(* read the first character and subtract 48 to get value in decimal 0 = 48 *)
	x := @pt;
	(* calculate the value of the digit *)
	IF X > 47 AND x < 56 THEN
		OCT_TO_BYTE := SHL(OCT_TO_BYTE,3) + X - 48;
	END_IF;
	pt := pt + 1;
END_FOR;



(* revision histroy
hm	18. jun. 2008	rev 1.0
	original release

hm	20. sep. 2008	rev 1.1
	changed length of input string from 20 to 10

*)	

]]>
				</sourceCode>
			</function>
			<function name="TO_UPPER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.3	16. jan. 2009
programmer 	hugo
tested by		oscat

to_upper converts a character from lowercase to uppercase

*)

IF in > 96 AND in < 123 THEN
   TO_UPPER := in AND 16#DF;
ELSIF in > 223 AND in <> 247 AND in <> 255 AND setup.EXTENDED_ASCII THEN
   TO_UPPER := in AND 16#DF;
ELSE
   TO_UPPER := in;
END_IF;




(* revision history
hm	6. mar. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changed setup constants

ks	25. oct. 2008	rev 1.2
	optimized code

hm 16. jan 2009	rev 1.3
	corrected an error in module

*)
]]>
				</sourceCode>
			</function>
			<function name="TO_LOWER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<returnValue>BYTE</returnValue>
				<vars>
					<inputVars>
						<var name="IN" type="BYTE"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<sourceCode type="ST">
					<![CDATA[


(*
version 1.2	25. oct 2008
programmer 	hugo
tested by		tobias

to_lower converts a character from uppercase to lowercase

*)

IF in > 64 AND in < 91 THEN
   TO_LOWER := in OR 16#20;
ELSIF (in > 191 AND in < 223) AND in <> 215 AND setup.EXTENDED_ASCII THEN
   TO_LOWER := in OR 16#20;
ELSE
   TO_LOWER := in;
END_IF;


(* revision history
hm	6. mar. 2008	rev 1.0
	original version

hm	19. oct. 2008	rev 1.1
	changed setup constants

ks	25. oct. 2008	rev 1.2
	optimized code
*)
]]>
				</sourceCode>
			</function>
		</functions>
		<functionBlocks>
			<functionBlock name="MESSAGE_4R" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<vars/>
				<iecDeclaration active="FALSE"/>
				<interfaces/>
				<methods/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT
	M0 : STRING[STRING_LENGTH];
	M1 : STRING[STRING_LENGTH];
	M2 : STRING[STRING_LENGTH];
	M3 : STRING[STRING_LENGTH];
	MM : INT := 3;
	ENQ : BOOL := TRUE;
	CLK : BOOL := TRUE;
	T1 : TIME := T#3s;
END_VAR
VAR_OUTPUT
	MX : STRING[STRING_LENGTH];
	MN : INT;
	TR : BOOL;
END_VAR
VAR
	timer : TON;
	edge: BOOL;
END_VAR

(*
version 1.1	27. oct. 2008
programmer 	hugo
tested by	tobias

this function generates a rotation meassage with up to 4 strings.
on each rising edge of EN the next message in line will be displayed.
when EN stays high longer then one cycle, the next message will be displayed automatically after the time T1 is elapsed.
the output MX is the generated message and CX is a counter 0..3 signaling the current message displayed.
the displayed messages are 0 .. MM.

*)


(* check for rising edge on EN *)
TR := FALSE;
IF ENQ THEN
	IF (NOT edge AND clk) OR timer.q THEN
			MN := INC1(MN, MM);
			TR := TRUE;
			timer(in := FALSE);
			CASE MN OF
				0 : MX := M0;
				1 : MX := M1;
				2 : MX := M2;
				3 : MX := M3;
			END_CASE;
	END_IF;
	edge := clk;
	timer( in := CLK, pt := T1);
ELSE
	MX := '';
	MN := 0;
END_IF;




(* revision history
hm	8. oct. 2008	rev 1.0
	original version

hm	27. oct. 2008	rev 1.1
	changed _INC to INC1

*)

]]>
				</sourceCode>
			</functionBlock>
			<functionBlock name="MESSAGE_8" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<vars>
					<inputVars>
						<var name="IN1" type="BOOL"/>
						<var name="IN2" type="BOOL"/>
						<var name="IN3" type="BOOL"/>
						<var name="IN4" type="BOOL"/>
						<var name="IN5" type="BOOL"/>
						<var name="IN6" type="BOOL"/>
						<var name="IN7" type="BOOL"/>
						<var name="IN8" type="BOOL"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<interfaces/>
				<methods/>
				<sourceCode type="ST">
					<![CDATA[
VAR_INPUT 
	S1 : STRING[STRING_LENGTH];
	S2 : STRING[STRING_LENGTH];
	S3 : STRING[STRING_LENGTH];
	S4 : STRING[STRING_LENGTH];
	S5 : STRING[STRING_LENGTH];
	S6 : STRING[STRING_LENGTH];
	S7 : STRING[STRING_LENGTH];
	S8 : STRING[STRING_LENGTH];
END_VAR
VAR_OUTPUT
	M : STRING[STRING_LENGTH];
END_VAR


(*
version 1.1	29. mar. 2008
programmer 	hugo
tested by	tobias

this function generates one out of 4 messages specified by S1 .. S8.
the selected message will be presented at the output M.
In1 has higher priority then In2 which has higher priority then IN3 and in8 has the lowest priority.
*)


(* check if an alarm is present if yes set the output M otherwise clear M *)
IF in1 THEN
	M := S1;
ELSIF in2 THEN
	M := S2;
ELSIF in3 THEN
	M := S3;
ELSIF in4 THEN
	M := S4;
ELSIF in5 THEN
	M := S5;
ELSIF in6 THEN
	M := S6;
ELSIF in7 THEN
	M := S7;
ELSIF in8 THEN
	M := S8;
ELSE
	M := '';
END_IF;

(* revision history
hm	26.12.2007		rev 1.0
	original version

hm	29. mar. 2008	rev 1.1
	changed STRING to STRING(STRING_LENGTH)
*)

]]>
				</sourceCode>
			</functionBlock>
			<functionBlock name="TICKER" version="1.0.0" creationDate="0" lastModifiedDate="0" excludeFromBuild="FALSE" excludeFromBuildIfNotDef="">
				<vars>
					<inputVars>
						<var name="N" type="INT"/>
						<var name="PT" type="TIME"/>
					</inputVars>
				</vars>
				<iecDeclaration active="FALSE"/>
				<interfaces/>
				<methods/>
				<sourceCode type="ST">
					<![CDATA[

VAR_IN_OUT
	Text : STRING[STRING_LENGTH];
END_VAR

VAR_OUTPUT
	Display : STRING[STRING_LENGTH];
END_VAR
VAR
	delay : TP;
	step : INT;
END_VAR

(*
version 1.2	29. mar. 2008
programmer 	hugo
tested by		tobias

Ticker sends a substring of text with length N every TD Milliseconds to generate a ticker. 

*)


(* generate next ticker when delay is low *)
IF N < LEN(text) THEN
	IF NOT delay.Q THEN
		(* increase step for next tick *)
		step := step + 1;
		IF step > LEN(text) THEN step := 1; END_IF;
		(* extract dispay from text *)
		display := MID(text, N, step);
		(* set delay timer for next tick *)
		delay(in := TRUE, PT := PT);
	ELSE;
		(* execute delay timer *)
		delay(in := FALSE);
	END_IF;
ELSE
	display := text;
END_IF;
(* revision history
hm	4. dec. 2007	rev 1.0
	original version

hm	15. dec. 2007	rev 1.1
	step now starts at 1 instaed of 0

hm	29. mar. 2008	rev 1.2
	changed STRING to STRING(STRING_LENGTH)
*)
]]>
				</sourceCode>
			</functionBlock>
		</functionBlocks>
		<programs/>
		<macros/>
		<structs/>
		<typedefs/>
		<enums/>
		<subranges/>
		<interfaces/>
	</lib>
</plcLibrary>
