<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="X-UA-Compatible" content="IE=Edge">
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" >
	<title>CAN Variables list</title>
	<script type="text/javascript">
		try
		{ csspath = "file://" + window.external.CatalogPath + "../Common/CSS/" }  // chiede il csspath all'applicazione host
		catch (e)
		{ csspath = document.cookie.slice(8) }  // ricava il csspath dal cookie chiamato 'csspath'

		document.write("<LINK href='" + csspath + "style.css' rel='stylesheet' type='text/css'>")
		// deprecato: ora lo stile di varslist e' incluso nel CSS generico
		// document.write("<LINK href='" + csspath + "varslist.css' rel='stylesheet' type='text/css'>")
		document.write("<SCRIPT src='" + csspath + "../script/common.js' type='text/javascript'></" + "SCRIPT>")

		var FLAG_NO_RO = 1
		var FLAG_NO_WO = 2
		var FLAG_ONLY_PDOMAPPING = 4
		var FLAG_NO_RWW = 8
		var FLAG_NO_RWR = 16

		var m_existingVars
		var m_curFilter
		var m_flags
		var m_showSplitBits
		var m_parMap

		function Init()
		{
			// reset var risultato
			window.external.TempVar("selectedVar") = undefined
			
			//toglie l'ultimo carattere '/' dal datapath
			var nodexml = datapath.value.slice(0, -1);

			// crea dictionary per ricerca veloce
			m_existingVars = new ActiveXObject("Scripting.Dictionary")

			m_parMap = window.external.TempVar("varsList_parMap")
			var indexPath = window.external.TempVar("varsList_Index_path")
			var subindexPath = window.external.TempVar("varsList_SubIndex_path")
			m_flags = window.external.TempVar("varsList_Flags")
			m_showSplitBits = window.external.TempVar("varsList_showSplitBits")

			if (!m_showSplitBits)
				divSplit.style.display = "none"
			
			// se tutte le variabili sono corrette effettua il filtro
			if (nodexml && m_parMap && indexPath && subindexPath)
			{
				// estrae nodi già presenti
				var nodeslist = window.external.SelectNodesXML( nodexml )
				var node
				while( node = nodeslist.nextNode() )
				{
					var idx = parseInt(node.selectSingleNode(indexPath).nodeTypedValue)
					var sub = parseInt(node.selectSingleNode(subindexPath).nodeTypedValue)
					var key = m_parMap.BuildIndex(idx, sub)
					if (! m_existingVars.Exists(key))
						// non dovrebbero mai esserci variabili duplicate salvo errori nell'EDS originale...
						m_existingVars.Add(key, 1)
				}
			}
			
			FillList()
		}

		function IsDummyObject(idx)
		{
			// l'oggetto è dummy se ha indice del tipo 1.0 .. 7.0 (ovvero il suo DataType)
			return parseInt(idx) <= 7
		}

		function FillList()
		{
			if (filter.value.toLowerCase() == m_curFilter)
				// tasto che non ha modificato il filtro (es frecce)
				return
			
			m_curFilter = filter.value.toLowerCase()
			
			// lista di inserimento
			var tempList = []
			
			// svuotamento lista
			list.options.length = 0;
			
			var data, pos
			
			// riempie la lista solo con elementi non presenti
			for (var i in m_parMap)
			{
				var obj = m_parMap[i]
				
				if (typeof obj == "function")
					continue
					
				if (!m_existingVars.Exists(i) || IsDummyObject(i))
				{
					if ((m_flags & FLAG_NO_RO) && obj.readOnly)
						continue   // salta i parametri readonly (per setlist)
					
					if ((m_flags & FLAG_ONLY_PDOMAPPING) && !obj.PDOMapping)
						continue   // salta i par senza PDOMapping
						
					if ((m_flags & FLAG_NO_WO) && obj.AccessType == "wo")
						continue   // salta i parametri writeonly
						
					if ((m_flags & FLAG_NO_RWR) && obj.AccessType == "rwr")
						continue   // salta i parametri r/w ma mappabili solo in PDOTx
						
					if ((m_flags & FLAG_NO_RWW) && obj.AccessType == "rww")
						continue   // salta i parametri r/w ma mappabili solo in PDORx
						
					var s = i + "   " + obj.name
					if (obj.typeIEC)
						s += "   (" + obj.typeIEC + ")"
					
					// aggiunge se nessun filtro o filtro ok
					if (m_curFilter == "" || s.toLowerCase().indexOf(m_curFilter) != -1)
					{
						// l'itemdata dell'elemento del listbox è un long con hiword=index e loword=subindex
						pos = i.lastIndexOf(".")
						data = (parseInt(i.substr(0, 4),16) << 8) + parseInt(i.substr(pos+1, 2),16)
						
						var tempObj = {}
						tempObj.str = s
						tempObj.data = data
						
						tempList.push(tempObj)
					}
				}
			}

			// ordino la lista in base a index.subindex
			if (tempList.length > 1)
				tempList.sort(compareByData);
				
			// inserisco in modo ordinato
			for (var i = 0; i < tempList.length; i++)
			{
				var option = document.createElement("option");
				option.text = tempList[i].str;
				option.value = tempList[i].data;
				list.add(option);
			}
		}

		function compareByData(a,b)
		{
			if (a.data < b.data)
				return -1;
			if (a.data > b.data)
				return 1;
			return 0; 
		}

		function CloseOK()
		{
			var result = []
			
			// crea array con elenco risultati
			var tot = list.options.length;
			for (var i = 0; i < tot; i++)
			{
				var option = list.options[i];
				if (option.selected)
				{
					// l'itemdata dell'elemento del listbox è un long con hiword=index e loword=subindex
					var value = option.value;
					var str = (value >> 8).toString(16) + "." + (value & 0xFF).toString(16);
					result.push(str);
				}
			}
			
			window.external.TempVar("varsList_result") = result
			window.external.TempVar("varsList_splitBits") = m_showSplitBits ? chkSplit.checked : false
			CloseDlg()
		}

		function OnListDblClick()
		{
			if (list.selectedIndex != -1)
				// doppio click sulla lista seleziona e conferma
				CloseOK();
		}

		function OnListClick() {
			if (m_showSplitBits && list.options.length == 1)
			{
				// cerca il primo (e unico) elemento selezionato
				for (var i = 0, tot = list.options.length; i < tot; i++)
				{
					var option = list.options[i];
					if (option.selected)
					{
						// l'itemdata dell'elemento del listbox è un long con hiword=index e loword=subindex
						var index = option.value >> 8
						// attiva il check 'split' per default se oggetto digitale DS401
						chkSplit.checked = app.CallFunction("CANcustom.IsDigitalObject", index, m_parMap)
						break
					}
				}
			}
		}
	</script>
</head>

<body class="varslist" onload="Init()">
	<input type="hidden" name=".DATAPATH" id="datapath">

	<div class="container">
		<div>
			<label for="filter"><t:t>Filter</t:t>: </label><input style="width: 330px" type="text" id="filter" onkeyup="FillList()">
		</div>

		<div id="divSplit" align="right">
			<input type="checkbox" id="chkSplit">
			<label for="chkSplit" style="position:relative; top:-3px"><t:t>Split single bits</t:t></label>
		</div>

		<div class="list-container mt-xs">
			<select id="list" multiple ondblclick="OnListDblClick()" onclick="OnListClick()"></select>
		</div>

		<div class="btn-container">
			<button class="FlatButton" onclick="CloseOK()"><t:t>OK</t:t></button>
			<button class="FlatButton" onclick="CloseDlg()"><t:t>Cancel</t:t></button>
		</div>
	</div>
</body>
</html>