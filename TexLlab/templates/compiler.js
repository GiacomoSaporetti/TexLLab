function Init(obj)
{
	return 1
}


var genfuncs = app.CallFunction("common.GetGeneralFunctions")
var gentypes = app.CallFunction("common.GetGeneralTypes")
var enuLogLevels = gentypes.enuLogLevels

var HEADER_AUTOGENERATED = "(* Automatically generated by %1, do not edit! *)\n"
var PLC_HEADER = "\tVAR_GLOBAL"
var PLC_FOOTER = "\tEND_VAR"

// codici di errore restituiti da AlCommand
var ALINTF = {
	NOERR: 0,
	ERRNOAPP: 1,
	ERRNOMANAGER: 2,
	ERROPEN: 3,
	ERRCLOSE: 4,
	ERRSAVE: 5,
	ERRCONNECT: 6,
	ERRDOWNLOAD: 7,
	ERRCOMPILE: 8,
	ERRALREAYEXISTS: 9
}


var m_appName
function SetAppName(name)
{ m_appName = name }

var m_logiclabName
function SetLogicLabName(name)
{ m_logiclabName = name }

// FileSystemObject di uso generale
var m_fso = new ActiveXObject("Scripting.FileSystemObject")

var m_isCompiling = false

// codice di errore ultima compilazione
var m_lastErrorCode

var ERRORCODES = {
	OK: 0,
	PREPROCESS: 1
}

function GetErrorCodes()
	{ return ERRORCODES }

// flags per compilazione selettiva
var COMPILATIONPHASE = {
	ONSAVE: 0,
	PREBUILD: 1,
	POSTBUILD: 2,
	PREDOWNLOAD: 3,
	POSTDOWNLOAD: 4
}

function GetCompilationPhase()
	{ return COMPILATIONPHASE }

var PHASE_NAMES = {
	0: "OnSave",
	1: "PreBuild",
	2: "PostBuild",
	3: "PreDownload",
	4: "PostDownload"
}

var OUTPUTTABS = {
	BUILD: 0,
	FIND: 1,
	DEBUG: 2,
	RESOURCES: 3
}

function Go(phase)
{
	// verifica flag per evitare ricorsione della compilazione
	if (m_isCompiling)
		return enuLogLevels.LEV_ERROR
	
	m_isCompiling = true
	m_lastErrorCode = ERRORCODES.OK
	
	// validazione iniziale se richiesto
	if (! ValidateAll(phase))
	{
		app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.RESOURCES)
		m_isCompiling = false
		return enuLogLevels.LEV_CRITICAL
	}
	
	app.CallFunction("common.ClearLogs")
	var result
	
	var d = new Date()
	app.PrintMessage(" ", enuLogLevels.LEV_INFO)
	app.PrintMessage("--- Start compilation  (" + PHASE_NAMES[phase] + ")  " + d.toLocaleTimeString() + " ---", enuLogLevels.LEV_INFO)

	//	Path del documento .pcn
	var pcnPath = app.GetDocumentPath();
	if( ! pcnPath )
	{
		m_isCompiling = false
		return genfuncs.AddLog(enuLogLevels.LEV_CRITICAL, "Go", "Please save current project before configuring this device", "/" )
	}

	// pulizia errori precedenti
	app.TempVar("ErrorPath") = undefined
	app.TempVar("ErrorRow") = undefined
	app.TempVar("ErrorCol") = undefined

	
	// esportazione variabili PLC sul salvataggio
	if (phase == COMPILATIONPHASE.ONSAVE)
	{
		// come prima cosa all'inizio della onsave cancella TUTTI gli auxsource, ad oggi al lato pratico vengono sempre rigenerati tutti nella onsave
		// NB: sono esclusi dalla rimozione gli externalFile (usati ad es. per PLC+HMI integrato)
		if ( app.CallFunction("logiclab.RemoveAuxSource", "*") )
		{
			m_LogicLab_PendingSave = true
		}
		
		result = ExportVars("GetExportPLCVars", "GetExportPLCFile")

		if (result != enuLogLevels.LEV_CRITICAL)
			result = ExportVars("GetExportExtVars", "GetExportExtFile")
	}
	
	
	// fase di CustomBuild
	if (result != enuLogLevels.LEV_CRITICAL)
	{
		// abilitare spostamento del tab attivo se il processo di postbuild è molto lungo
		//if (phase == COMPILATIONPHASE.POSTBUILD)
		//	app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.RESOURCES)
			
		result = CustomBuild(phase)
	
		//if (result != enuLogLevels.LEV_CRITICAL)
		//	app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.BUILD)
	}
	
	
	if (result == enuLogLevels.LEV_CRITICAL)
	{
		app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.RESOURCES)
		
		m_isCompiling = false
		LogicLab_CloseIntf(true)
		return enuLogLevels.LEV_CRITICAL
	}
	
	d = new Date()
	app.PrintMessage("--- End   compilation  (" + PHASE_NAMES[phase] + ")  " + d.toLocaleTimeString() + " ---", enuLogLevels.LEV_INFO)
	
	// salvataggio, preprocess e chiusura interfaccia
	result = LogicLab_CloseIntf(false, (phase != COMPILATIONPHASE.ONSAVE))
	if (result == enuLogLevels.LEV_CRITICAL)
	{
		SelectTabWithError()
		m_isCompiling = false
		return enuLogLevels.LEV_CRITICAL
	}
	
	m_isCompiling = false
	return enuLogLevels.LEV_OK
}


// seleziona il tab corretto con il msg di errore
function SelectTabWithError()
{
	if (m_lastErrorCode == ERRORCODES.PREPROCESS)
		// fuoco al tab di build se fallito preprocess (es. nome di variabile non valida)
		app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.BUILD)
}

function SelectResourcesTab()
{
	app.CallFunction("extfunct.SelectOutputTab", OUTPUTTABS.RESOURCES);
}

// radice del documento xml (/configuration/data)
function GetDocRoot()
{
	return app.SelectNodesXML("/")[0]
}

// procedura di validazione di tutti i nodi aventi funzioni di validate
function ValidateAll(phase)
{
	var ok = true
	
	var nodelist = genfuncs.SearchNodesWithAttribute(GetDocRoot(), "ValidateFunc", -1)
	for (var i = 0; i < nodelist.length; i++)
	{
		var node = nodelist[i]
		var func = node.getAttribute("ValidateFunc")
		if (func)
		{
			var result = app.CallFunction(func, node, phase)
			if (result == enuLogLevels.LEV_CRITICAL)
			{
				ok = false
				break   // errore critico, interrompe la catena
			}
			else if (result == enuLogLevels.LEV_ERROR)
				ok = false
		}
	}
	
	return ok
}


function ExportVars(varsFunc, fileFunc)
{
	var listExpPlc = genfuncs.SearchNodesWithAttribute(GetDocRoot(), "ExportPLCVars", -1)

	//	Path del documento .pcn
	var pcnPath = app.GetDocumentPath();
	if( ! pcnPath )
		return genfuncs.AddLog(enuLogLevels.LEV_ERROR, "LLExec.BuildConfig", "Please save current project before configuring this device")
	pcnPath = m_fso.GetParentFolderName( pcnPath )

	for (var i = 0; i < listExpPlc.length; i++)
	{
		var root = listExpPlc[i]
		var prjpath
		
		// lettura path progetto da interfaccia logiclab con framework integrato, esiste per forza!
		prjpath = app.CallFunction("logiclab.get_ProjectPath")
			
		var extname = root.getAttribute("ExtensionName")
		
		// scrittura del file PLC con nome custom
		var fileinfo = app.CallFunction(extname + "." + fileFunc, root)
		if (!fileinfo)
			continue
			
		// ottiene l'elenco delle variabili da esportare dalla funzione custom del device
		var list = app.CallFunction(extname + "." + varsFunc, root)
		
		var map = {}
		for (var j = 0; j < list.length; j++)
		{
			var newitem = list[j]
			
			// verifica validità campi
			if (!newitem.label || !newitem.type || !newitem.dataBlock)
			{
				var err = genfuncs.SplitFieldPath(newitem.node)
				return genfuncs.AddLog(enuLogLevels.LEV_CRITICAL, "ExportVars", "Invalid PLC variable: " + newitem.label, err)
			}
			
			// verifica non duplicazione variabili
			if (map[newitem.label] != undefined)
			{
				var err = genfuncs.SplitFieldPath(newitem.node)
				return genfuncs.AddLog(enuLogLevels.LEV_CRITICAL, "ExportVars", "Duplicate PLC variable: " + newitem.label, err)
			}
			
			map[newitem.label] = newitem
		}
		
		var path = m_fso.GetParentFolderName(prjpath)
		
		path += "\\" + fileinfo.filename
		
			//generazione delle variabili
		var strPlc = GeneratePlc( list, fileinfo.header, fileinfo.footer )
		if( strPlc == null ) 
			return enuLogLevels.LEV_CRITICAL
		
			//aggiornamento delle variabili plc all'interno del progetto
		if (LogicLab_UpdatePLC( prjpath, fileinfo.filename, strPlc ))
			genfuncs.AddLog(enuLogLevels.LEV_INFO, "ExportVars", "Created " + path + " (" + list.length + " vars)", "", "")
		else
		{
			genfuncs.AddLog(enuLogLevels.LEV_INFO, "ExportVars", "ERROR creating " + path + " : Can not update " + prjpath, "", "")
			return enuLogLevels.LEV_CRITICAL
		}
	}
	
	return enuLogLevels.LEV_OK
}

function GeneratePlc( list, header, footer )  
{
	var strPlc = HEADER_AUTOGENERATED.replace("%1", m_appName)
		
	if (header)
		strPlc += header + "\n"
		
	// genera l'elenco solo se almeno una variabile presente
	if (list.length != 0)
	{
		strPlc += PLC_HEADER + "\n"
			
		var arrStr = []
		for (var i = 0; i < list.length; i++)
		{
			var item = list[i]
			
				//scrittura del gruppo se esiste
			if( item.group )
				arrStr.push("\t\t{G:\"" + item.group + "\"}\n")
			
				//check validità nome variabile
			if( !isValidVarName(item.label) )
			{
				var err = genfuncs.SplitFieldPath(item.node)
				genfuncs.AddLog(enuLogLevels.LEV_CRITICAL, "GeneratePlc", "Invalid PLC variable name: " + item.label, err)
				return null
			}

			arrStr.push("\t" + item.label )
			
			if (item.dataBlock != -1)
			{
				// datablock ok
				if (item.dataBlock.substr(0,1) == "%")
					arrStr.push(" AT " + item.dataBlock)
				else
					arrStr.push(" AT %" + item.dataBlock)
			}
			arrStr.push(" : ")
			
			if (item.type != "STRING" && item.size)
				// definizione array
				arrStr.push("ARRAY[0.." + (item.size-1) + "] OF ")
			
			arrStr.push(item.type)
			
			if (item.type == "STRING" && item.size)
				// dimensione stringa
				arrStr.push("[ " + item.size + " ]")
				
			if (item.defaultValue !== undefined && item.defaultValue !== null)
			{
				if (item.type == "STRING")
					// valore di inizializzazione stringa, quota con apici
					arrStr.push(" := '" + item.defaultValue + "'")
				else if (!isNaN(item.defaultValue))
					// valore di inizializzazione numerico, solo se numero valido
					arrStr.push(" := " + item.defaultValue)
			}
			
			arrStr.push(";")
			
			if (item.description)
				// aggiunge descrizione della variabile, sostituisce " con '
				arrStr.push('  {DE:"' + item.description.replace(/"/g, "'") + '"}')
				
			arrStr.push("\n")
		}
		
		arrStr.push(PLC_FOOTER + "\n")
		strPlc += arrStr.join("")
	}

	if (footer)
		strPlc += footer
		
	return strPlc;
}

// funzione per la verifica del nome di una variabile
function isValidVarName(name)
{
	return app.CallFunction("script.CheckVarName", name, true);
}



var m_LogicLabIntf = undefined
var m_LogicLab_CanClose = false
var m_LogicLab_PendingSave = false

// inizializza l'interfaccia di automazione con logiclab, se possibile riutilizzando quella esistente se c'è già
function LogicLab_OpenIntf(prjpath)
{
	if (!m_LogicLabIntf)
	{
		// creazione nuova interfaccia OLE
		m_LogicLabIntf = app.GetExtensionDispatch("logiclab")
			
		if (!m_LogicLabIntf)
		{
			app.PrintMessage("ERROR: can not open " + m_logiclabName + " interface!", enuLogLevels.LEV_CRITICAL)
			return false
		}
		
		// il progetto potrà essere chiuso alla fine se interfaccia di automazione semplice o istanza completa ma senza progetto aperto
		// questo script era originariamente usato da configuratore esterno aggianciando a processo LogicLab tramite interfaccia OLE;
		// se usato all'interno del AlFramework LogicLab, sarà sempre FALSE!
		m_LogicLab_CanClose = m_LogicLabIntf.automation || !m_LogicLabIntf.opened
	}
	
	if (m_LogicLabIntf.opened)
	{
		if (m_LogicLabIntf.projectPath.toLowerCase() == prjpath.toLowerCase())
			// ok progetto già aperto giusto
			return true
		else if (m_LogicLab_CanClose)
		{
			// progetto già aperto che però si può chiudere
			if (m_LogicLab_PendingSave)
			{
				m_LogicLabIntf.Save()
				m_LogicLab_PendingSave = false
			}
			m_LogicLabIntf.Close()
			
			return (m_LogicLabIntf.Open(prjpath, false) == 0)
		}
		else
		{
			// progetto già aperto ma che non si può chiudere
			app.MessageBox("Another instance of " + m_logiclabName + " is opened with a different project!\nClose project " + m_LogicLabIntf.projectPath + " and retry", 
							m_appName, gentypes.MSGBOX.MB_OK|gentypes.MSGBOX.MB_ICONERROR)
			return false
		}
	}
	else
		// nessun progetto già aperto
		return (m_LogicLabIntf.Open(prjpath, false) == 0)
}

// chiude l'interfaccia di automazione con logiclab salvando le modifiche apportate al progetto
function LogicLab_CloseIntf(abort, savePrj)
{
	if (!m_LogicLabIntf)
		return enuLogLevels.LEV_ERROR
	
	var result = enuLogLevels.LEV_OK
		
	if (m_LogicLabIntf.opened)
	{
		if (m_LogicLab_PendingSave && !abort)
		{
			if (savePrj)
				// salva il progetto se modifiche pendenti
				m_LogicLabIntf.Save()
		
			// ricarica i simboli se istanza completa di logiclab che aveva già il progetto aperto all'inizio
			if (!m_LogicLab_CanClose && m_LogicLabIntf.ReloadAuxSources() != ALINTF.NOERR)      // 8 = ERRCOMPILE
			{
				app.PrintMessage("ERROR reloading aux sources", enuLogLevels.LEV_CRITICAL)
				// comunica il fallimento del preprocess degli aux per abortire la compilazione
				result = enuLogLevels.LEV_CRITICAL
				m_lastErrorCode = ERRORCODES.PREPROCESS
			}
		}
		
		if (m_LogicLab_CanClose)
			m_LogicLabIntf.Close()
	}
	
	m_LogicLab_PendingSave = false
	m_LogicLab_CanClose = false
	m_LogicLabIntf = undefined
	return result
}

// comunica a logicLab l'aggiornamento dei sorgenti ausiliari tramite interfaccia OLE
function LogicLab_UpdatePLC(prjpath, plcName, plcContent, externalFile, order, isHidden)
{
	if (!LogicLab_OpenIntf(prjpath))
		return
	
	// valori di default per parametri opzionali mancanti
	if (externalFile === undefined)
		externalFile = false
	
	if (order === undefined)
		order = 0
	
	if (isHidden === undefined)
		isHidden = false

	if (m_LogicLabIntf.AddAuxSource2(plcName, plcContent, externalFile, order, isHidden) == 0)
	{
		m_LogicLab_PendingSave = true
		return true
	}
	else
		return false
}

// comunica a logicLab la rimozione del sorgente ausiliario tramite interfaccia OLE
function LogicLab_RemovePLC(prjpath, plcName)
{
	if (!LogicLab_OpenIntf(prjpath))
		return
	
	if (m_LogicLabIntf.RemoveAuxSource(plcName))
	{
		m_LogicLab_PendingSave = true
		return true
	}
	else
		return false
}


// invocazione funzione custom (specifica del target) per la build
function CustomBuild(phase)
{
	var nodelist = genfuncs.SearchNodesWithAttribute(GetDocRoot(), "CustomBuildFunc", -1)
	for (var i = 0; i < nodelist.length; i++)
	{
		var node = nodelist[i]
		var func = node.getAttribute("CustomBuildFunc")
		if( app.CallFunction(func, node, phase) == enuLogLevels.LEV_CRITICAL )
			return enuLogLevels.LEV_CRITICAL
	}
	return enuLogLevels.LEV_OK
}


// invocazione funzione custom (specifica del target) per il download
function CustomDownload(phase, errcode)
{
	var nodelist = genfuncs.SearchNodesWithAttribute(GetDocRoot(), "CustomDownloadFunc", -1)
	for (var i = 0; i < nodelist.length; i++)
	{
		var node = nodelist[i]
		var func = node.getAttribute("CustomDownloadFunc")
		if( app.CallFunction(func, node, phase, errcode) == enuLogLevels.LEV_CRITICAL )
			return enuLogLevels.LEV_CRITICAL
	}
	return enuLogLevels.LEV_OK
}
